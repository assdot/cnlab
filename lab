 
 
 
1. Write a program to implement error detection/ error correction using hamming code. 
Hamming code is a block code that is capable of detecting up to two simultaneous bit errors and 
correcting single-bit errors. It was developed by R.W. Hamming for error correction. In this coding 
method, the source encodes the message by inserting redundant bits within the message. These 
redundant bits are extra bits that are generated and inserted at specific positions in the message itself 
to enable error detection and correction. When the destination receives this message, it performs 
recalculations to detect errors and find the bit position that has error. 
 
#include<stdio.h>  
void main() { 
 int data[10]; 
 int dataatrec[10],c,c1,c2,c3,i; 
  
printf("Enter 4 bits of data one by one\n"); 
scanf("%d",&data[0]); 
scanf("%d",&data[1]); 
scanf("%d",&data[2]); 
scanf("%d",&data[4]); 
 // calculate even parity 
data[6]=data[0]^data[2]^data[4]; 
data[5]=data[0]^data[1]^data[4]; 
data[3]=data[0]^data[1]^data[2]; 
 printf("\nEncoded data is\n"); 
 
for(i=0;i<7;i++) 
        printf("%d",data[i]); 
 printf("\n\nEnter received data bits one by one\n"); 
 for(i=0;i<7;i++) 
        scanf("%d",&dataatrec[i]); 
  
c1=dataatrec[6]^dataatrec[4]^dataatrec[2]^dataatrec[0]; 
c2=dataatrec[5]^dataatrec[4]^dataatrec[1]^dataatrec[0]; 
c3=dataatrec[3]^dataatrec[2]^dataatrec[1]^dataatrec[0]; 
c=c3*4+c2*2+c1 ; 
  
    if(c==0) { 
printf("\nNo error while transmission of data\n"); 
    } 
else { 
printf("\nError on position %d",c); 
     
printf("\nData sent : "); 
        for(i=0;i<7;i++) 
 
            printf("%d",data[i]); 
         
printf("\nData received : "); 
        for(i=0;i<7;i++) 
            printf("%d",dataatrec[i]); 
 
printf("\nCorrect message is\n"); 
  //if errorneous bit is 0 we complement it else vice versa 
if(dataatrec[7-c]==0) 
dataatrec[7-c]=1; 
 else 
dataatrec[7-c]=0; 
for (i=0;i<7;i++) { 
printf("%d",dataatrec[i]); 
} 
} 
return 0; 
} 
Output:  Case 1 without error 
 
Case 2: with error 
  
 
 
 
 
 
2. Write a program to show working of the Stop and wait protocol.   
 
 
Stop and wait protocol is the simplest flow control method. In this, the sender will transmit one 
frame at a time to the receiver. The sender will stop and wait for the acknowledgement from the 
receiver. This time (i.e. the time joining message transmitting and acknowledgement receiving) is the 
sender’s waiting time, and the sender is idle during this time. When the sender gets the 
acknowledgement (ACK), it will send the next data packet to the receiver and wait for the disclosure 
again, and this process will continue as long as the sender has the data to send. 
Characteristics  
It is used in Connection-oriented communication. 
 It offers error and flows control. 
 It can be used in data Link and transport Layers. 
 Stop and Wait ARQ executes Sliding Window Protocol with Window Size 1 
 
 
 
 
 
 
 
#include<iostream> 
#include <time.h> 
#include <cstdlib> 
#include<ctime> 
#include <unistd.h> 
using namespace std; 
class timer { 
    private: 
     unsigned long begTime; 
    public: 
     void start() { 
      begTime = clock(); 
     } 
  unsigned long elapsedTime() { 
      return ((unsigned long) clock() - begTime) / CLOCKS_PER_SEC; 
    } 
   bool isTimeout(unsigned long seconds) { 
      return seconds >= elapsedTime(); 
     } 
}; 
int main() 
{ 
 int frames[] = {1,2,3,4}; 
 unsigned long seconds = 5; 
 srand(time(NULL)); 
 timer t; 
 cout<<"Sender has to send frames : "; 
 for(int i=0;i<4;i++) 
     cout<<frames[i]<<" "; 
 
 cout<<endl; 
 int count = 0; 
 bool delay = false; 
 cout<<endl<<"Sender\t\t\t\t\tReceiver"<<endl; 
do 
 { 
     bool timeout = false; 
     cout<<"Sending Frame : "<<frames[count]; 
     cout.flush(); 
     cout<<"\t\t"; 
     t.start(); 
     if(rand()%2) 
     { 
         int to = 2450 + rand()%(6400 - 2450)  + 1; 
             for(int i=0;i<6400;i++) 
             for(int j=0;j<to;j++) {} 
     } 
     if(t.elapsedTime() <= seconds) 
     { 
         cout<<"Received Frame : "<<frames[count]<<" "; 
         if(delay) 
         { 
             cout<<"Duplicate"; 
             delay = false; 
         } 
         cout<<endl; 
         count++; 
     } 
     else 
 
     { 
         cout<<"---"<<endl; 
         cout<<"Timeout"<<endl; 
         timeout = true; 
     } 
t.start(); 
     if(rand()%2 || !timeout) 
     { 
         int to = 24500 + rand()%(64000 - 24500)  + 1; 
         for(int i=0;i<64000;i++) 
             for(int j=0;j<to;j++) {} 
         if(t.elapsedTime() > seconds ) 
         { 
             cout<<"Delayed Ack"<<endl; 
             count--; 
             delay = true; 
         } 
         else if(!timeout) 
             cout<<"Acknowledgement : "<<frames[count]-1<<endl; 
     } 
 }while(count!=4); 
 return 0; 
} 
Output: 
 
  
3. Implementation of CSMA/CD.        
       
Consider a scenario where there are ‘n’ stations on a link and all are waiting to transfer data 
through that channel. In this case, all ‘n’ stations would want to access the link/channel to transfer 
their own data. The problem arises when more than one station transmits the data at the moment. 
In this case, there will be collisions in the data from different stations.  
CSMA/CD is one such technique where different stations that follow this protocol agree on some 
terms and collision detection measures for effective transmission. This protocol decides which 
station will transmit when so that data reaches the destination without corruption. 
Working principal: 
Step 1: Check if the sender is ready for transmitting data packets. 
 
Step 2: Check if the transmission link is idle.  
Sender has to keep on checking if the transmission link/medium is idle. For this, it continuously 
senses transmissions from other nodes. Sender sends dummy data on the link. If it does not receive 
any collision signal, this means the link is idle at the moment. If it senses that the carrier is free and 
there are no collisions, it sends the data. Otherwise, it refrains from sending data. 
 
Step 3: Transmit the data & check for collisions.  
Sender transmits its data on the link. CSMA/CD does not use an ‘acknowledgment’ system. It 
checks for successful and unsuccessful transmissions through collision signals. During 
transmission, if a collision signal is received by the node, transmission is stopped. The station then 
transmits a jam signal onto the link and waits for random time intervals before it resends the frame. 
After some random time, it again attempts to transfer the data and repeats the above process. 
 
Step 4: If no collision was detected in propagation, the sender completes its frame transmission 
and resets the counters. 
 
 
 
 
#include <iostream> 
#include <cstdlib> // for rand()  
#include <ctime>   // for time() 
 
class Station { 
public: 
    Station(std::string name) : name(name) {} 
 
    void send() { 
 
        if (carrierBusy()) { 
            std::cout << name << " detects carrier busy, deferring transmission." << std::endl; 
            return; 
        } 
 
        std::cout << name << " is sending a message." << std::endl; 
 
        if (collisionDetected()) { 
            std::cout << name << " detects a collision, stopping transmission." << std::endl; 
        } else { 
            std::cout << name << " successfully transmitted the message." << std::endl; 
        } 
    } 
   bool carrierBusy() { 
        // Simulate a random chance of the carrier being busy 
         return rand() % 2 == 1; 
          } 
            bool collisionDetected() { 
                                 // Simulate a random chance of a collision 
             return rand()*% 2 == 1; 
                              } 
                     private: 
                                      std::string name; 
    }; 
 
 
           int main() { 
                
              Station stationA("Station A"); 
             Station stationB("Station B"); 
              int i=1; 
          // Simulate both stations trying to send messages 
          while(i<=10){ 
                std::cout<<"Scenario"<<i<<std::endl; 
                stationA.send(); 
                 stationB.send(); 
                i++; 
            } 
                return 0; 
 
       } 
     
 
Output: 
 
 
 
 
 
 
 
4. Write a program to implement Distance Vector Routing algorithm.  
 
A distance-vector routing (DVR) protocol requires that a router inform its neighbors of topology 
changes periodically. Historically known as the old ARPANET routing algorithm (or known as 
Bellman-Ford algorithm). 
Bellman Ford Basics – Each router maintains a Distance Vector table containing the distance 
between itself and ALL possible destination nodes. Distances,based on a chosen metric, are 
computed using information from the neighbors’ distance vectors. 
 
Distance Vector Algorithm – 
1. A router transmits its distance vector to each of its neighbors in a routing packet. 
2. Each router receives and saves the most recently received distance vector from each of its 
neighbors. 
3. A router recalculates its distance vector when: 
 It receives a distance vector from a neighbor containing different information than before. 
 
 It discovers that a link to a neighbor has gone down. 
 
#include<stdio.h> 
#include<iostream> 
using namespace std;                                             
struct node 
{ 
    unsigned dist[6]; 
    unsigned from[6]; 
}DVR[10]; 
int main() 
{ 
    cout<<"\n\n-------------------- Distance Vector Routing Algorithm----------- "; 
    int costmat[6][6]; 
    int nodes, i, j, k; 
    cout<<"\n\n Enter the number of nodes : "; 
    cin>>nodes; //Enter the nodes 
    cout<<"\n Enter the cost matrix : \n" ; 
    for(i = 0; i < nodes; i++) 
     { 
        for(j = 0; j < nodes; j++) 
        { 
            cin>>costmat[i][j]; 
            costmat[i][i] = 0; 
            DVR[i].dist[j] = costmat[i][j]; //initialise the distance equal to cost matrix 
            DVR[i].from[j] = j; 
        } 
    } 
            for(i = 0; i < nodes; i++) //We choose arbitary vertex k and we calculate the 
            //direct distance from the node i to k using the cost matrix and add the distance from k to 
node j 
            for(j = i+1; j < nodes; j++) 
            for(k = 0; k < nodes; k++) 
                if(DVR[i].dist[j] > costmat[i][k] + DVR[k].dist[j]) 
                {   //We calculate the minimum distance 
                    DVR[i].dist[j] = DVR[i].dist[k] + DVR[k].dist[j]; 
                    DVR[j].dist[i] = DVR[i].dist[j]; 
                    DVR[i].from[j] = k; 
                    DVR[j].from[i] = k; 
                } 
        for(i = 0; i < nodes; i++) 
        { 
            cout<<"\n\n For router: "<<i+1; 
            for(j = 0; j < nodes; j++) 
                cout<<"\t\n node "<<j+1<<" via "<<DVR[i].from[j]+1<<" Distance "<<DVR[i].dist[j]; 
        } 
    cout<<" \n\n "; 
    return 0; 
 
} 
Output: 
 
 
 
 
 
 
 
 
Least cost tree using link state protocol 
 
5. Creating a C++ program for the least cost tree using the Link State Routing algorithm 
requires simulating a network of nodes and performing the Link State algorithm. Below is 
a simplified example of how you can implement it: 
 
```cpp 
#include <iostream> 
#include <vector> 
#include <climits> 
 
using namespace std; 
 
const int INF = INT_MAX; 
 
class Network { 
public: 
    int numNodes; 
    vector<vector<int>> costMatrix; 
 
    Network(int nodes) : numNodes(nodes) { 
        costMatrix.resize(nodes, vector<int>(nodes, INF)); 
    } 
 
    void addLink(int node1, int node2, int cost) { 
        costMatrix[node1][node2] = cost; 
        costMatrix[node2][node1] = cost; 
    } 
 
    void printLeastCostTree(int source, const vector<int>& parent) { 
        cout << "Least Cost Tree:" << endl; 
        for (int i = 0; i < numNodes; ++i) { 
            if (i != source) { 
                cout << "Node " << i << " -> Node " << parent[i] << " (Cost: " << 
costMatrix[i][parent[i]] << ")" << endl; 
            } 
        } 
    } 
 
    void linkStateRouting(int source) { 
        vector<int> distance(numNodes, INF); 
        vector<bool> inTree(numNodes, false); 
        vector<int> parent(numNodes, -1); 
 
 
        distance[source] = 0; 
 
        for (int i = 0; i < numNodes - 1; ++i) { 
            int u = getMinDistanceVertex(distance, inTree); 
            inTree[u] = true; 
 
            for (int v = 0; v < numNodes; ++v) { 
                if (!inTree[v] && costMatrix[u][v] != INF && distance[u] + costMatrix[u][v] 
< distance[v]) { 
                    parent[v] = u; 
                    distance[v] = distance[u] + costMatrix[u][v]; 
                } 
            } 
        } 
 
        printLeastCostTree(source, parent); 
    } 
 
    int getMinDistanceVertex(const vector<int>& distance, const vector<bool>& inTree) 
{ 
        int minDistance = INF; 
        int minVertex = -1; 
 
        for (int v = 0; v < numNodes; ++v) { 
            if (!inTree[v] && distance[v] < minDistance) { 
                minDistance = distance[v]; 
                minVertex = v; 
            } 
        } 
 
        return minVertex; 
    } 
}; 
 
int main() { 
    int numNodes = 4; 
    Network network(numNodes); 
 
    // Add links with their costs 
    network.addLink(0, 1, 4); 
    network.addLink(0, 2, 2); 
    network.addLink(1, 2, 5); 
    network.addLink(1, 3, 10); 
    network.addLink(2, 3, 1); 
 
 
    int sourceNode = 0; 
    network.linkStateRouting(sourceNode); 
 
    return 0; 
} 
 
6. To write echo client-server application using TCP. 
// TCP server side 
 
//Include headers 
#include<stdio.h> 
#include<netinet/in.h> 
#include<netdb.h> 
#include<arpa/inet.h> 
#include<unistd.h> 
//Define server port  
#define SERV_TCP_PORT 5035 
int main(int argc,char**argv) 
{ 
  //variable declaration 
       int sockfd,newsockfd; 
       socklen_t clength; 
       struct sockaddr_in serv_addr,cli_addr; 
       char buffer[4096]; 
 
   // create socket  
       sockfd=socket(AF_INET,SOCK_STREAM,0); 
   
   //Initialize server addres structure 
       serv_addr.sin_family=AF_INET; 
       serv_addr.sin_addr.s_addr=INADDR_ANY; 
       serv_addr.sin_port=htons(SERV_TCP_PORT); 
 
       printf("\nStart"); 
 // bind socket  
       bind(sockfd,(struct sockaddr*)&serv_addr,sizeof(serv_addr)); 
       printf("\nListening..."); 
       printf("\n"); 
//Listen incoming connection  
       listen(sockfd,5); 
 
// accept connection from client  
       clength=sizeof(cli_addr); 
       newsockfd=accept(sockfd,(struct sockaddr*)&cli_addr,&clength); 
       printf("\nConnection Accepted"); 
       printf("\n"); 
//Read client message  
       read(newsockfd,buffer,4096); 
       printf("\nClient message:%s",buffer); 
//echo back to client 
       write(newsockfd,buffer,4096); 
       printf("\n"); 
//close sockets  
       close(sockfd); 
       close(newsockfd); 
       return 0; 
} 
 
 
//TCP client side 
#include<stdio.h> 
#include<sys/types.h> 
#include<sys/socket.h> 
#include<netinet/in.h> 
#include<netdb.h> 
#include<unistd.h> 
#include<arpa/inet.h> 
#define SERV_TCP_PORT 5035 
int main(int argc,char*argv[]) 
{ 
       int sockfd; 
       struct sockaddr_in serv_addr; 
       struct hostent *server; 
       char buffer[4096]; 
 
       sockfd=socket(AF_INET,SOCK_STREAM,0); 
       serv_addr.sin_family=AF_INET; 
       serv_addr.sin_addr.s_addr=inet_addr("127.0.0.1"); 
       serv_addr.sin_port=htons(SERV_TCP_PORT); 
 
       printf("\nReady for sending..."); 
       connect(sockfd,(struct sockaddr*)&serv_addr,sizeof(serv_addr)); 
       printf("\nEnter the message to send\n"); 
       printf("\nClient: "); 
       fgets(buffer,4096,stdin); 
 
       write(sockfd,buffer,4096); 
       printf("Serverecho:%s",buffer); 
       printf("\n"); 
       close(sockfd); 
       return 0; 
} 
 
Output: 
 
At server terminal     At client terminal 

 
 
 
